from lxml import etree
import requests
import os
import json
import re
import subprocess
import random

__version__ = 'v0.1.0'
__author__ = 'chaziming'

HEADERS = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                         'Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56'}


def getHtml(baseurl):
    head = {
        "user-agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                      'Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56'
    }
    try:
        response = requests.get(url=baseurl, headers=head)
        # 200表示服务器接受请求，会传回网页源代码，所以把文本内容传回来就行了
        if response.status_code == 200:
            return response.text
    except:
        print("请求失败")


def getVideo(baseurl, p):
    html = getHtml(baseurl)
    pattern = r'\<script\>window\.__playinfo__=(.*?)\</script\>'
    result = re.findall(pattern, html)[0]
    temp = json.loads(result)

    title = etree.HTML(html)

    title = title.xpath('//div[@id="viewbox_report"]/h1/span/text()')[0]
    title = str(title + p)
    title = title.replace(' ', '')
    print(title)
    print(("开始下载--->") + title)

    print('开始下载视频')
    video_url = temp['data']['dash']['video'][0]['baseUrl']

    audio_url = temp['data']['dash']['audio'][0]['baseUrl']
    fileDownload(homeurl=baseurl, url=video_url, title=title, typ=0)
    print('开始下载音频')
    fileDownload(homeurl=baseurl, url=audio_url, title=title, typ=1)

    print('正在合成音频')
    combine(title)


def fileDownload(homeurl, url, title, typ):
    # 添加请求头键值对,写上 refered:请求来源
    headers = {
        "user-agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                      'Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56'}
    headers.update({'Referer': homeurl})
    if typ == 0:
        filename = "./" + title + ".flv"
    else:
        filename = "./" + title + ".mp3"
    res = requests.Session()
    # 指定每次下载1M的数据
    i = random.randint(1020, 1050)
    begin = 0
    end = i * 1024 - 1
    flag = 0
    while True:
        # 添加请求头键值对,写上 range:请求字节范围
        i = random.randint(1020, 1050)
        headers.update({'Range': 'bytes=' + str(begin) + '-' + str(end)})
        # 获取视频分片
        res = requests.get(url=url, headers=headers)
        if res.status_code != 416:
            # 响应码不为416时有数据，由于我们不是b站服务器，最终那个数据包的请求range肯定会超出限度，所以传回来的http状态码是416而不是206
            begin = end + 1
            end = end + i * 1024
        else:
            print(end)
            headers.update({'Range': str(end + 1) + '-'})
            res = requests.get(url=url, headers=headers)
            flag = 1
        with open(filename, 'ab') as fp:
            fp.write(res.content)
            fp.flush()
        if flag == 1:
            print('下载成功')
            fp.close()
            break


def combine(title):
    COMMAND = f'ffmpeg -i {title}.flv -i {title}.mp3 -c:v copy -c:a aac -strict experimental {title}.mp4 '
    subprocess.Popen(COMMAND, shell=True)


def main():
    print("欢迎来到bilibili爬资源小程序，接下来让我们开始吧(视频在最后可能会重播放，正在努力修复这个bug中，敬请谅解。)")
    bv = input("输入视频bv号: ")
    p = input('请输入视频p号（默认为1）')
    if p == '':
        p = '1'
    baseurl = "https://www.bilibili.com/video/BV" + str(bv) + "?p=" + str(p)
    getVideo(baseurl, p)
    os.system("pause")


if __name__ == "__main__":
    main()
    print('合成完毕，请观看')
